from torch

torch.tensor(n)
torch.from_numpy(x) #creates torch tensor from np array. doesnt make copy
torch.randn(rows, columns, *requires_grad)

										~operations~
torch.sum() #calculates sum of elements in a tensor
t.grad.zero_()

torch.max(probs, *dim) #returns max_probs, preds

torch.no_grad() #turns off gradient tracking

										~TENSOR PROPERTIES~
t.dtype
t.shape
t.size
t.grad
t.device 

torch.numel(t) #gives no of elements
t.t() #gives transpose
t.backward() #computes derivative
t.view(dim) #changes dimension of original memory block
t.size(n) #gives dimension of dim n 

t.reshape(dim) #returns reshaped tensor into given dims
torch.stack(tuple, *dim) #stacks tuple of tensors into tensor
										~nn package~
from torch.nn
nn.linear(inputs, outputs) #creates linear model ob
model(inputs) #gives predictions from input tensor

from torch.nn.functional as f
f.mse_loss(pred, target) #creates ob for calculating loss

from torch.optim.sgd as opt
opt.SGD(model.parameters(), *lr) #creates optimizer for updating params
ob.step() #update params with new gradients
ob.zero_grad() #resets grads

import torch.nn.functional as f
f.softmax(pred, *dim) #produces probabilities from prediction tensors
f.cross_entropy(data) #gives cross entropy loss tensor from model prediction. Softmax applied internally.

nn ob propertes:
model.weight #gives weights of model
model.bias #gives bias of model
model.parameters #gives tuple of parameters

										~torch vision trash~
from torchvision.datasets
datasets.MNIST(*root, *download, *train, *transform) 
#creates dataset ob of MNIST data set at root. *train=false for training set
#*transform=transforms.ToTensor() from torchvision.transforms for returning tensor

datasets.download_url('link', *dir) #download dataset files from link.

#extract tarfile snippet:
import tarfile
with tarfile.open('dir', 'r:gz') as tar
tar.extractall(*path)


from matplotlib.pyplot as plt
plt.imshow(img, *cmap) #plots PIL img
										~data loading rubbish~
from torch.utils.data
data.TensorDataset(a, b) #creates tuple with preds and targets

from torch.utils.dataloader as d
d.DataLoader(dataset, batch_size, *sampler) #creates dataloader
from torch.utils.data.sampler as s
s.SubsetRandomSampler(indices) #creates sample from list of indices
										~cuda nonsense~
tensor.to(device, non_blocking=True) #moves tensor to device
