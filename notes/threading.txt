import threading
t = threading.Thread(*target, *args) # target ->function, args->func args
t.start()
t.join() # wait for thread to finish


import concurrent.futures
with concurrent.futures.ThreadPoolExecutor() as executor:
	f = executor.submit(func, args)
	f.result() #gives return of func. waits for result


	results = [executor.submit(do_something, 1 for _ in range(10))]
	#loops over results and produces results in order of completion:
	for f in concurrent.futures.as_completed(results):
		print(f)


	#instead of list comprehension:
	args = [arg1, arg2, ...]
	results = executor.map(func, args) 
	#returns results in order of starting thread. (Does not increase time)

#multiprocessing
import multiprocessing
p = multiprocessing.Process(*target, *args) # target ->function, args->func args
p.start()
p.join() # wait for thread to finish

with concurrent.fuftures.ProcessPoolExecutor() as executor:
	f = executor.submit(func, args)
	f.result() #gives return of func. waits for result


	results = [executor.submit(do_something, 1 for _ in range(10))]
	#loops over results and produces results in order of completion:
	for f in concurrent.futures.as_completed(results):
		print(f)


	#instead of list comprehension:
	args = [arg1, arg2, ...]
	results = executor.map(func, args) 
	#returns results in order of starting thread. (Does not increase time)
